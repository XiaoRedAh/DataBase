关系的定义及性质
关系模式与关系实例  
理解三类关系完整性
关系的候选键、主键、外键
用关系代数表达查询
关系代数的基本运算   
掌握选择、投影、连接、差运算等  
除运算不考查
关系演算不考查


安全性与完整性差别
实现数据库安全性的措施
角色的定义及作用
角色是被命名的一组与数据库操作相关的权限。角色是批量用户授权操作的需要，简化了授权的过程

关系模型中的三类完整性规则，各有什么要求
针对基本关系或依赖关系，哪些操作会破坏完整性；各种操作破坏这些完整性规则的处理方法（拒绝、级联、置空）  
触发器的定义及主要作用（详细语法结构不考查）
触发器是在有触发事件后，满足一定的触发条件而执行一组动作的一个特殊的存储过程。它主要用来实现完整性，也可以实现一些自动操作。


# 关系模型概览

**关系模型是一种数据模型**，是关系数据库的理论基础

对应于数据模型的三要素，**关系模型的三要素**为：
* 单一数据结构 —— 关系
* 数据操作 —— 关系操作（这里重点学关系代数）
* 数据完整性 —— 关系完整性
  * 实体完整性
  * 参照完整性
  * 用户定义的完整性

# 数据结构—关系

## 基本概念

**关系的定义**
* 数学上：定义在域D1, D2, …, Dn上的关系R是**笛卡儿积D1×D2×…×Dn的一个命名子集（有意义的元组构成笛卡尔积的一个子集，赋予其名字，就是关系）**
  * R即是关系名。
  * R⊆D1×D2×…×Dn
* 在关系模型的术语中，关系用来指代表

**关系的组成**
* 关系的一列是属性，属性必定有名字（属性名）
* 关系的一行是元组
* 分量是行和列的交叉，也就是某个元组的某个属性（值）
* 关系的度: 属性的数目
* 关系的基数: 元组的数目
* 属性的域: 属性可能取值的集合

**关系的性质（必须满足的条件）**
* **列是同质的**。列中的分量类型必须相同，因为它们来自同一个域。
* 不同的列可来自同个域，但**属性名不能相同**
* 关系里的**任意两行不能相同**，因为关系是一个元组集合（数学上禁止，实际数据库里可以容忍重复，用主键区分）
* 关系的**行或列是无序的**。即改变行或列的次序，关系不会变
* **属性值(分量)必须是原子的(不可分)**。多值属性，复合属性都是非原子的。关系必须满足第一范式

## 关系的码

**超键**：一个或多个属性的集合。通过超键可以唯一地标识关系中的每一个元组。

**候选键**：不含多余元素的超键，也称为最小超键。一个关系可以有多个候选键。

**主键**：选择一个候选键作为主键，每个关系有且仅有一个主键。

**外键**：关系R1中的单个属性或属性集合，对应关系R2的主码。R1称为参照关系，R2称为被参照关系。【注意：这时值的参照，而非名字的参照。外键和对应主码的属性名不一定要相同】

**几个问题**
>Q：实体集有哪些码？
A：超码，候选码，主码
Q：关系有哪些码？
A：超码，候选码，主码，外部码
Q：关系的外部码是如何“得来”的?
A：从联系集转化而来
Q：外部码能对应同一个关系中的主码么？
A：可以。比如学生分为组长和组员两个角色，联系是指导和被指导

## 关系模式和实例

**关系模式**是关系的逻辑设计（结构），对应于编程语言的类型定义，由属性序列及各属性对应域组成【数据库中，表的结构（属性）】。完整定义如下：
R(U, D, dom, F)
* R: 关系名
* U: 关系属性的集合
* D:　　域的集合　
* Dom: 属性到域的映射(每个属性是什么域的?)
* F: 属性间依赖关系的集合

简记为R(A1, A2, …, An)。A1, A2, …, An 为 R中的所有属性

**关系实例**【数据库中，表的具体内容（元组）】
* 对应于编程语言中变量的值，即在某一特定时刻上关系的具体内容
* 提到“关系”时，有时指“关系实例”，有时指“关系模式”

**举例**

关系student的关系模式：student(sno,name,sex)
关系student的关系实例：
|sno|name|sex|
|--|--|--|
|1|小明|男|
|2|小红|女|

**比较**

关系模式比较稳定，不常变化。而关系实例随时间而变化，原因是元组不断被插入/删除/更新。

# 数据操作—关系操作

## 查询语言概述

关系操作：对关系进行操作，常见的有查询操作和修改操作。查询操作是修改操作的基础，修改操作实际是对查询出来的结果进行修改。

关系操作的表示：**查询语言**
* **关系模型中使用“纯”查询语言**，如关系代数、关系演算
  * 关系代数：用关系运算来表示查询和修改。
  * 关系演算：用谓词演算来表示查询和修改。根据谓词的不同，又分为元组关系演算和域关系演算
* **关系数据库中使用实际的查询语言**，如SQL

**查询语言的分类**
* **过程化**：用户要指定 ① what: 查询什么 ② how: 怎么查询，要用什么样的方法、过程？
* **非过程化**：用户只要指定查询什么，而“怎么查询”的问题留给系统处理，系统会自动寻找(近似)最优的查询方法，又叫查询执行计划。

**关系代数是过程化的，SQL和关系演算是非过程化**

## 什么是关系代数

**代数系统的组成**
* 运算对象
* 基于运算对象的一组运算

**关系代数**
关系 —— 运算对象
选择，投影，…… —— 基于关系的一组运算

**关系代数是封闭的，任何关系运算的结果还是一个关系**

**关系运算的分类**
* **基本运算**：选择；投影；笛卡儿积；集合并；集合差；更名
* **附加运算**（非基本的，可以用基本运算的组合来替换）：集合交；自然连接；除法；赋值
* **扩展运算**（前两种基础上对运算能力进行扩展和增强）：广义投影；外连接；聚集运算

## 具体看书

这部分涉及大量的符号，不好写，看书+做题就行。

# 数据完整性—关系完整性

## 基本概述

**完整性的原义**：数据的完整性指的是数据的正确性、有效性和相容性。而大多数情况下，提到的完整性是指完整性规则。为保证完整性，数据应该满足的约束条件，又称为完整性约束

在关系模型中，完整性又称为**关系完整性**
① 实体完整性
② 参照完整性
③ 用户定义完整性

**用于解决现实世界映射到关系数据库后，产生的三类问题**
① 如何保证映射以后，一个实体是可识别（区分）的【实体完整性】
② 如何保证映射以后，能够从一个实体找到另一个相关联的实体，而不会出现找不到的情况【参照完整性】
③ 如何保证映射以后，实体属性的取值是合理的【用户定义完整性】


**完整性控制**：保证数据是正确、有效、相容的，**由DBMS负责**，包括两方面
① **完整性规则的定义**。通过SQL，按用户需求和数据语义，定义一组完整性规则/约束
② **完整性规则的检查**。运行时，通过专门的“完整性子系统”，验证数据是否总是满足这组规则。（谁来检查、什么时候检查）    
完整性子系统执行过程如下：
监督事务执行，检查数据的输入、输出是否违反完整性规则
如有违反现象，采取相应措施 (拒绝、报告、改正)

## 实体完整性

**规则**：元组在主码上取唯一值，且每个属性均不能为空【如果主码由多个属性构成，则每个属性都不能取空值】

**意义**：在实体映射为元组后，**不同元组靠主码来相互区分**。保证每一元组/实体，可与其它元组/实体是可区分的

**定义**：在创建或修改关系的定义语句中，用`PRIMARY KEY`关键字声明主码，即**定义一个主码约束**
```sql
create  table  关系名(
……
[ , primary  key (属性 {, 属性}) ]
……
)
```

**处理规则**（何时检查）
* 删除：无需检查
* 插入：如果插入的记录中主键值有null或者重复，则违反规则，拒绝插入，甚至回滚事务
* 修改：如果修改的主键值有空或者重复，则拒绝修改，甚至回滚事务

## 参照完整性

**外键的来源**：由联系集转化而来，反映实体（元组）之间的联系

**规则**：假设关系R的外部码对应关系S的主码，则R每个元组的**外部码的取值要么等于空值，要么等于某个对应的主码值**（S某个元组的主码值）

**意义**：元组/实体的外部码，说明跟另外哪一个元组/实体（的主码）是相联系的。**保证这一联系有意义，不会联系不存在的元组/实体**。

**定义**：在创建或修改关系的定义语句中，用`FOREIGN KEY`关键字声明外键，即**定义一个外键约束**

```sql
create table 表名( 
……
{ , foreign key (属性名 {, 属性名}) 
references 关系名 (属性名 {, 属性名}) 
on delete <参照动作>
on update <参照动作>}
……
)
```

**参照动作**：说明当某个主码值被删除/更新时（被参照关系中），如何处理对应的外键值（参照关系的，外键值=被删/改的这个主码）
① **RESTRICT**：仅当没有任何对应的外码值时，才可以删除/更新这个主码值，否则系统拒绝执行此操作
② **CASCADE**：连带将所有对应的外码值一起删除/更新（删除外码值，实际上就是将所在的元组删除掉）【级联删除/更新】
③ **SET NULL**：将所有对应的外码值设为空值

**处理规则**
**参照表**：增，改操作如果违反参照完整性，则拒绝。删除操作不用检查。
**被参照表**：增操作不用检查。删，改操作如果违反参照完整性，则按照参照表声明外键时指定的on delete，on update的规则处理


举例
```sql
create table 学生 (
学号 VARCHAR (4) primary key,
……
)

create table  选修(
学号  VARCHAR (4),
……,
foreign key (学号) references 学生(学号)
on delete restrict  
on update cascade, 
……,
)
```

## 用户定义完整性

用户根据具体的应用环境定义
* **唯一约束unique**
  在创建或修改关系的定义语句中，用`Unique`关键字对指定的一个属性或属性组合，不允许出现重复值.(一般给候选键用唯一约束)
* **非空约束not null**
  在定义关系的语句中，对某个属性声明`not null`，使其属性值不允许取空值
* **域约束**
  用定义语句创建一个域，如果某属性的数据类型声明为这个域，那么该属性的取值只能在这个域中取。
  定义：在创建域的语句中，用constraint子句说明约束的名称和条件
  ```sql
  create domain 用户域名 预定义域  
  [constraint约束名 check (条件)]
  ```
* **检查约束check**
  在创建或者修改关系的语句中，用`check`子句声明检查约束。关系中每一个元组的各个属性值，必须满足用户指定的条件
* **断言**
* **触发器**（一种保证完整性的机制）：一种“自动执行”的过程
  触发器是在有触发事件后，满足一定的触发条件而执行一组动作的一个特殊的存储过程。它主要用来实现完整性，也可以实现一些自动操作。
  构成如下：
  * 事件：说明什么时候激活（执行）触发器（Insert、Update、Delete等）
  * 条件：说明满足什么条件时，才执行下面的动作
  * 动作：说明（条件成立后）要执行的代码

***
**唯一约束举例**
```sql
create table 学生(
……,
身份证号  VARCHAR (15),
……,
unique (身份证号),
……
)
```


***
**非空约束举例**
```sql
create table 学生(
姓名 VARCHAR(20) not null,
……,
)
```
  
***
**域约束举例**
```sql
create domain Age_Domain SMALLINT  
  constraint   Age_Constraint
  check (value>=0 AND value<=200)

create table 学生(
学号 VARCHAR (4),
姓名 VARCHAR (20),
年龄 Age_Domain,
primary key (学号),
……
)
```

***
**检查约束举例**
CET4是一个记录四级成绩的表，如何保证“grade”的值（及格、不及格两档）和“result”的值能够正确对应?
```sql
create table CET4(
sno VARCHAR (20),
grade VARCHAR (10),
result FLOAT,
primary key (sno),
check ((grade=“及格” and result between 420 and 710)
or (grade=“不及格” and result between 0 and 419))
)
```

# 关系安全性

**安全性控制**
目的是保证数据库的任何部分都不会受到未授权（未经许可）的访问和修改，防止数据泄露和被破坏

**两类安全性问题和解决机制**
① **非法用户**
“未授权的使用”：未经许可的用户进入和使用数据库。
解决这一问题的方法为**系统保护机制，即设置用户帐号和密码**

② **非法操作**
“非授权的存取”：经过许可的用户进入数据库系统后，对某些数据进行了未经许可的操作。
解决这一问题的的方法称为**存取控制机制**

**和完整性控制的对比**
安全性控制是为了**防止用户是“非法”的，和防止操作是“非法的”**（用户合法，但执行操作超出了权限范围）
完整性控制是为了**防止数据是非法**的，即任何情况下都不能产生错误的数据，即使是合法的用户和合法的操作



