事务概念，事务状态，事务调度
# 基本概念

**事务定义**：事务是由一系列访问和更新操作组成的程序执行单元。这些操作要么都做，要么都不做，是一个不可分割的整体

**SQL中的事务**
事务以`Begin transaction`语句开始(SQL Server是Start Transaction)，以`Commit` 或`Rollback`语句结束
* `Commit`：提交事务。此时事务正常结束，事务所做的修改操作都必须**永久地写入数据库**
* `Rollback`：回滚事务。此时事务非正常结束，事务所做的**修改操作都必须撤销(Undo，数据改回旧值)**。数据库回退到事务开始前的状态，就好像事务从来没有发生过一样。
* 如果事务还没有来得及执行Commit，就因某种原因（故障）而终止了，那么系统就要自动地回滚这个事务

*注意：commit=写入日志!=写入磁盘。永久写入数据库指的是写入磁盘，而这个操作其实是操作系统调度的（将非热点数据写入磁盘）*

**事务四大特性（ACID）**

* **原子性(Atomicity)**：事务的所有操作(特指修改操作)要么全部做，要么都不做。通过`恢复机制`实现
* **一致性(Consistency)**：独立执行一个事务（无其它事务同时并发执行）的结果必须保证数据一致性。即事务开始前，数据满足一致性要求；事务结束后，数据虽然变化了，但仍然满足一致性的要求。由`程序员负责`，借助`完整性机制`实现。
  * 例如在银行系统中，转帐事务的一致性要求是前后两个帐户的金额总和不变。假如一个事务为帐户A减去100，为帐户B加上50，那么这个事务就违反了一致性。
* **隔离性(Isolation)**：任何一对事务T1、T2，在T1看来，T2要么在T1开始之前已经结束，要么在T1结束以后再开始执行 (T2对数据库的修改，T1要么全部看到，要么全部看不到)。通过`并发控制机制`实现。
* **持久性(Durability)**：一个事务成功完成后，它对数据库的改变必须是永久的，即使系统出现故障。通过`恢复机制`实现。

**事务的读和写**

数据库的存储以块为单位，假设数据项X位于磁盘中的数据块B，事务T1，T2都要用到X，读写流程如下：

* input(B)将X从磁盘的B数据块输入到全局缓冲区，T1，T2分别read(X)将全局缓冲区的X读入到自己事务的私有缓冲区。
* T1用write(x)将事务T1的私有缓冲区中的X写回全局缓冲区，全局缓冲区通过output(B)将这个X输出到磁盘中的数据块B位置

![](pic/%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%AF%BB%E5%92%8C%E5%86%99.png)

综上，事务的读写分别用read(X)，write(X)表示，是在事务自己的主存缓冲区上操作。write(X)并不一定立即更新磁盘上的数据

**事务状态**

* **活动状态**：事务开始后进入
  * 事务处于本状态时，顺序执行事务中的每条语句
* **部分提交状态**：执行完事务的全部语句后进入
  * 事务处于本状态时，将已做的每个修改操作永久化，即把对应的日志记录写入到磁盘上。这样即使修改操作后来丢失了（比如磁盘损坏），也能根据这些日志记录（永久化信息）来恢复它
* **提交状态**：提交全部修改操作后进入
  * 事务处于本状态时，**事务结束**
* **失败状态**
  * 在活动状态中，执行某条语句失败时进入
  * 在部分提交状态中，（对某个修改操作）永久化失败时进入
  * 事务处于本状态时，不断回滚已经发生的修改操作
* **中止状态**：回滚事务，数据库恢复到事务执行前的状态后进入
  * 事务处于本状态时，**事务结束**

![](pic/%E4%BA%8B%E5%8A%A1%E7%8A%B6%E6%80%81.png)

执行一个事务可能经过的状态：

* 活动状态 → 部分提交状态 → 提交状态
* 活动状态 → 失败状态 → 中止状态
* 活动状态 → 部分提交状态 → 失败状态 → 中止状态

# 详解事务隔离性

## 事务调度

**事务调度**：指系统执行事务中指令的时间顺序，必须保证：
* 包含了所有事务的操作指令
* 同一个事务中指令的相对顺序必须保持不变

**串行调度**：执行完一个事务才开始执行下一个事务。从时间顺序上看，同一事务的指令紧挨在一起

**并发调度**：未执行完一个事务时，可转去执行另一个事务。从时间顺序上看，不同事务的指令彼此交叉（多种执行顺序）

**并发调度优点**
* 提高系统吞吐量：给定时间内，执行的事务数增加
* 提高资源利用率：CPU与磁盘的空闲时间减少
* 减少等待时间
  * 减少不可预测的延迟：比如串行调度，短事务可能要等待前面的长事务完成，可能导致难以预测的延迟。
  * 减少`平均响应时间`(事务从提交到完成所需的平均时间)

*数据库使用并发执行的动机本质上与操作系统使用`多道程序`的动机是一样的*

**并发调度需要考虑是否违反隔离性**
* 串行调度多个事务时，不会破坏数据一致性。
* 并行调度多个事务时，可能会、也可能不会破坏数据一致性。这往往取决于并发调度是否违反隔离性


## 采用并发调度

### 问题与解决思路

**并发调度的问题**: 
一旦并发调度无法保证隔离性（**因**），就可能破坏数据一致性（**果**）。即使单个事务的执行可以保证一致性，但当多个这样的事务在并发调度时，也可能破坏数据一致性。

**解决方法**: 使并发调度*可串行化*
具体地说，对于一个并发调度
* 如果本身就是可串行化的，那么它就是一个正确的调度（隔离性得到保证，从而保证数据一致性），可以直接执行。
* 如果本身是不可串行化的，那就对其进行并发控制
  * 若并发控制改变了执行次序，将其改造成可串行化，那么这个并发调度就变成了一个正确的调度。
  * 若并发控制不能改变执行次序，无法将其改造成可串行化，那么这个并发调度是有问题的。

**错误的并发调度（没保证隔离性）带来的三个问题**
*本质都是看到中间态*

* **丢失修改(写覆盖)**：并发调度两个事务T1、T2。T1与T2从数据库中读入同一数据后分别修改。假设T1先提交，而T2后提交，则T2提交的修改覆盖了T1提交的修改，导致T1的修改丢失。
* **不可重复读**：事务T1读取某些数据（记录）后，事务T2对这些数据（记录）做了某种修改操作。当T1再次读取该数据（记录）时，得到的是与前一次不同的值。*分为三种情况—在事务T1两次读取之间：*
    * 另一事务T2更新了记录。则当T1第二次读取时，得到与前一次不同的记录值
    * 另一事务T2删除了部分记录。则当T1第二次读取时，发现其中的某些记录神秘地消失了（**幻影/幻读现象**）
    * 另一事务T2插入了一些记录。则当T1第二次按相同条件读取时，发现地神秘地多了一些记录（**幻影/幻读现象**）
* **读“脏”数据**：事务T1修改某一数据，并写入数据库，但尚未结束(提交)，事务T2读取同一数据，得到的是T1修改后的新值。事务T1由于某种原因被撤消，则数据库中的数据恢复为修改前的旧值。事务T2读到的数据就与数据库最终的数据不一致，是不正确的数据，又称为“脏”数据 —— 其它事务修改后但又被撤销（回滚）的数据。

*广义的“脏”数据：凡是另一事务修改过但是还没有提交的数据，对本事务来说都是“脏”的。在严格要求正确性的场合，读“脏”数据是不允许的*

*写覆盖举例：有数据项A=0，事务T1对A加200，事务T2对A加100。如果是串行调度，那没有问题，T1和T2谁先调度，最后的A都是300。但如果是错误的并发调度，T1的写回操作先执行的话，会被后执行的T2的写操作覆盖，导致最后的A是100；反之，最后的A是200。*

### 可串行化

事务的串行调度显然不会破坏数据一致性

**可串行化**：事务的并发调度效果上等价于某个串行调度。

*注意：不考虑一个事务对某一数据项可执行的不同类型的操作。**只考虑read和write。**（从调度角度看，事务唯一重要的操作是read和write）*

这里只讨论**冲突可串行化**

*注意：冲突可串行化是可串行化的充分条件，不是必要条件*

**判断事务T1的指令I和事务T2的指令J是否冲突**
*冲突指的是I，J执行的先后顺序对结果有影响*
* I，J操作的数据项不同，一定不冲突
* I，J操作的数据项相同
  * 都是read指令，则不冲突
  * 至少一个是write指令，则冲突（两个都是wirte看似不冲突，但会影响后来read的数据，所以冲突）

**冲突等价**：调度S经过一系列非冲突指令交换，变成调度S'，则称S与S'冲突等价。

**冲突可串行化**：如果调度S与一个串行调度冲突等价，则S是冲突可串行化的。

***
**例1**
并发调度S（包含T1，T2）

|T1|T2|
|--|--|
|read(A)||
|write(A)||
||read(A)|
||write(A)|
|read(B)||
|write(B)||
||read(B)|
||write(B)|

冲突等价于以下串行调度，因此是S是冲突可串行化的
|T1|T2|
|--|--|
|read(A)||
|write(A)||
|read(B)||
|write(B)||
||read(A)|
||write(A)|
||read(B)|
||write(B)|

**例二**
以下并发调度S不等价于任何一个串行调度，是不可串行化的

|T1|T2|
|--|--|
|read(A)||
||write(A)|
|write(A)||
***

### 并发控制机制

并发控制机制的任务：
* 正确地并发调度事务（可串行化）
* 保证事务的隔离性
* 保证数据一致性

#### 基于锁的协议

**封锁**：事务T在对某个数据对象（关系、元组等）进行操作之前，先向系统发出请求，对其加锁。事务T对某个数据对象加锁后，其它事务就不能对这个数据对象进行某些相应操作，直到事务T释放它的锁为止。

**封锁协议**：事务对数据对象加锁时，还需要遵守某些规则，包括：何时加锁，何时释放。称这些规则为封锁协议

**锁的相容函数**：事务Tj在数据项Q上拥有B类型锁，此时事务Ti请求对Q加A类型锁。如果可以立即获得Q上的A类型锁，就称A，B类型锁是相容的。

比如说，对数据项Q上A类型锁，只有等待Q上所有与A不相容类型的锁全部释放，才能对Q上A类型锁。

**锁的强度**：指它对其他锁的排斥程度。一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然

##### X锁与S锁

**封锁基本类型**
* **S锁（读锁/共享锁）share**
事务T 对数据对象A进行读取操作前，给A加上S锁。加上S锁后，其它事务能再对A加S锁，但不能加X锁，直到T释放A上的S锁为止
* **X锁（写锁/排它锁）exclusive**
事务T 对数据对象A进行修改操作前，给A加上X锁。加上X锁后，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的X锁为止

lock-S(Q)，lock-X(Q)分别对数据项Q上S锁和X锁，unlock(Q)释放数据项Q上的锁。

**S锁与X锁的相容矩阵**
这两种锁之间，只有S锁和S锁是相容的。
这保证了可以让多个事务读取一个数据项，但同时只能有一个事务进行写操作。

||S|X|
|--|--|--|
|S|true|false|
|X|false|false|

##### 一级封锁协议

**规定**：*若要修改数据R*，事务T必须先对其*加X锁*(数据R最早的读写操作前)，*X锁直到事务结束(commit或rollback后)才释放*

一级封锁协议可**解决丢失修改**的问题：
没有事务能够修改其它事务正在修改，还未提交的数据


##### 二级封锁协议

**规定**：一级封锁协议 + *若要读取数据R*，事务T必须先对其*加S锁*(数据R最早的读操作前)，在读完后，可以在*任意时候释放S锁*

二级封锁协议在一级协议的基础上，可**解决读脏数据**的问题：
没有事务能够读取其它事务正在修改，还未提交的数据（这样的数据是有X锁的，而X锁和S锁是不相容的，无法申请到S锁进行读取）

##### 三级封锁协议

**规定**：一级封锁协议 + *若要读取数据R*，事务T必须先对其*加S锁*(数据R最早的读操作前)，直到*事务结束后才释放S锁*

三级封锁协议在二级协议的基础上，可**解决不可重复读**的问题
没有事务能够修改其它事务正在读取的数据（这个数据持有事务A的S锁，另一事务B的写操作申请的X锁需要等待这个S锁的释放，而它是事务A结束后才释放的，因此....）

***
**小结**

|封锁协议|何时加X锁|何时释放X锁|何时加S锁|何时释放S锁|丢失修改|读脏数据|不可重复读|
|--|--|--|--|--|--|--|--|
|一级封锁协议|首次**读写**操作开始|事务结束|×|×|N|||
|二级封锁协议|首次**读写**操作开始|事务结束|读操作开始|读操作结束|N|N||
|三级封锁协议|首次**读写**操作开始|事务结束|读操作开始|事务结束|N|N|N|
***

##### 两阶段封锁协议

>二阶段封锁协议偏理论，判断精准，但实现难度大。真正的设计（DBMS）一般都采用一、二、三级封锁协议(虽然比较粗放，但已经足够)

**规定**：在对*任何数据进行读写之前，事务首先要获得对该数据进行封锁*，释放封锁后不能再读、写该数据。在释放第一个封锁之后，事务不再获得任何其它封锁，即事务分为两个阶段

* 生长阶段：事务可以获得锁，但不能释放锁	   
* 收缩阶段：事务可以释放锁，但不能获得新锁

首次释放掉一个封锁后，即由生长阶段转入收缩阶段

*可以理解为所有lock是一个串行调度S1，所有unlock是一个串行调度S2。S2只能在S1之后调度，lock和unlock调度顺序不允许出现交叉*

**定理**：若所有事务均遵从两段锁协议，则对这些事务的并行调度都是可串行化的

反过来，在一个可串行化调度中，不一定所有事务都遵从两段锁协议
因此，所有事务都遵从两段锁协议，是可串行化调度的充分不必要条件

##### 多粒度与意向锁

前面的并发控制机制，都是将单独的数据项作为同步执行的单元
有些时候，需要把多个数据项聚为一组，将它们作为一个同步单元

比如：事务Ti需要访问整个数据库。如果以单个数据项为同步单元，就需要对每个数据项封锁，非常耗时。如果能只发出单个加锁请求，就可以封锁整个数据库，那么效率会大大提高。

**多级粒度机制**：通过允许各种大小的数据项并定义数据粒度的层次结构，其中小粒度数据项嵌套在大粒度数据项中来实现。

**粒度设计要把握好度**：粒度大，开销减小，但并发性也会减小；粒度小，并发性会更好，但开销增大

**多粒度的层次结构可以用“树”表示**

树的每个结点可以单独加锁（显示的）。事务Ti对某结点显示地加锁后，该结点地全部后代会**隐式地**加上同样类型的锁。

![](https://tse2-mm.cn.bing.net/th/id/OIP-C.iHvMy9kWPv6bkH8JqGe3OAHaEZ?pid=ImgDet&rs=1)

**隐式加锁带来的问题**

比如ra被隐式加锁，事务Ti此时对ra发出加锁请求。由于ra没有显示加锁，系统应该如何判断Ti是否可以封锁ra呢？

解决方法：从树根遍历到ra，如果路径上某结点的锁与要加的锁类型不相容，则Ti必须推迟。

**如何判断根节点是否可以加锁**

* 遍历搜索整颗树：这个方法破坏了多粒度封锁机制的初衷
* 给一个结点显式加锁之前，给该结点的*全部祖先结点都加上意向锁*。这样就不必搜索整颗树了。

**意向锁**
* 目的：提高对某个数据对象加锁时系统的检查效率
* 对任一结点加基本锁，必须先对它的上层结点加意向锁
* 如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁

**常用意向锁**
* **IS锁**：如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。
* **IX锁**：如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁（也可以加S锁）。
* **SIX锁**：如果一个事务对一个数据对象加SIX锁，表示对这个事务对它加了S锁，再加IX锁，即SIX = S + IX。【**以该结点为根的子树显式地加S锁，树的更低层次显式地加IX锁**】
  * 比如：对某个表加SIX锁，表示该事务要读整个表（所以要对该表加S锁），同时会更新个别元组（所以要对该表加IX锁）。

**相容矩阵**：写累了，上网看就行。

##### 多粒度封锁协议

详细规则在意向锁的概念里有提及

* 申请封锁时应该按自上而下的次序进行
* 释放封锁时则应该按自下而上的次序进行

#### 基于时间戳的协议

课堂上没讲，先略。

#### 基于有效性检查的协议

课堂上没讲，先略

#### 多版本机制

课堂上没讲，先略

## 事务隔离级别





