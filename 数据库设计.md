# 前置

**关系模型**：对应于编程语言的类型定义，由属性序列及各属性对应域组成。

**关系实例**：对应于编程语言中变量的值。关系更新时，关系实例的内容可能随之发生改变，但关系模式是不变的。

在关系模型中，**关系**指代表，**元组**（记录）指代行，**属性**（字段）指代表中的列。

**超键**：一个或多个属性的集合。通过超键可以唯一地标识一个元组。

**候选键**：不含多余元素的超键，也称为最小超键。一个关系可以有多个候选键。

**主键**：选择一个候选键作为主键，每个关系有且仅有一个主键。

**外键**：如果关系模式 R1 中的属性 K 是其他关系模式R2的主键，那么 K 在R1上称作参照R2的外键。R1称为外键依赖的参照关系，R2称作外键的被参照关系。

**主属性**：包含在任一候选键中的属性

**非主属性**：不包含在任意候选中的属性

# 设计流程概览

* **需求分析**
* **概念设计**：定义数据库的实体，实体的属性，实体之间的联系，以及实体和联系上的约束。实体-联系模型（E-R模型）常用于此阶段，并构建出实体-联系图（E-R图）对模式进行图形化描述。
* **逻辑设计**：将高层概念模型（E-R模型）映射到将使用的数据库的实现数据模型（关系数据模型）上。
* **物理设计**：指明数据库的物理特征，包括文件组织格式和索引结构的选择。
* **数据库实施**
* **数据库运行维护**

****
数据模型：
数据库系统中，数据模型就是一组工具的集合，用于描述数据结构、数据操作、数据语义和完整性约束

数据模型与数据库：
数据模型可以描述数据库的模式（结构）。换句话说，给定一个具体的数据模型，我们可以把它转化为数据库的结构
因此，数据模型是定义数据库结构，或者说设计数据库的重要依据
****


# 需求分析

略

# 概念设计

## E-R模型

### 实体集

名词概念。

**实体集**：相同类型即具有相同性质（或属性）的一个实体集合。

**实体集的外延**：实体集的实体的实际集合。

比如：大学老师是一个实体集，大学老师中实际老师的集合是实体集的外延。

**实体集不必互不相交**：一个人既可以是学生实体，也可以是公民实体。

实体通过一组属性来表示。属性是实体集中每个成员所拥有的描述性性质。

### 联系集

动词概念。

**联系**：多个实体间的相互关联。联系中的实体可以来自不同的实体集，也可以来自同一个实体集

**联系集**：相同类型联系的集合。联系集也可以有起描述作用的属性。

**联系集的度**：参与联系集的实体类的数目称为。

**参与**：实体集与联系集间的关联。也就是说，如果联系集R 涉及到实体集E1, E2, …, En，那么我们说实体集E1, E2, …, En参与了联系集R

**一个实体集能够两次参与同个联系集**：学生中挑一位组长管理学生中的对应组的组员

**（实体的）角色**：实体集参与联系集时发挥的作用

* 如果实体集仅参与联系集一次，那么它只有一个角色且隐含在名字中，不用特别说明
* 如果实体集参与联系集两次或以上，那么相应地，它有两个或以上的角色。这时单靠实体的名字无法区分这些角色，需要单独说明每次以什么角色参与。（比如组长和组员这两个角色）


### 属性

**属性**：实体集中每个成员（实体）都拥有的，起描述作用的性质。正规的说，实体集的属性是将实体集映射到域的函数。

**域/值集**：属性可能取值的集合

属性可以有如下两种**划分**：

* 简单和复合属性
  * 简单属性：不能再划分
  * 复合属性：可以再划分（parent划分为father和mather），甚至可以有层次（address划分出一个子属性street，子属性street又划分出street_number，street_name）
* 单值和多值属性
  * 单值属性：比如出生年月
  * 多值属性：一个属性可能对应一组值。（phone_number属性，每个人可以有0，1，或多个电话号码）


派生属性：从别的相关属性或实体类派生出来。它的值不存储，而是在需要的时候计算出来。【比如：tax=0.5 * salary，tax是派生属性，salary是基属性】

## 约束

### 映射基数

映射基数表示一个实体通过一个联系集能关联的实体的个数（输入一个x得到几个y）。在描述二元联系集时非常有用。

对于实体集A，B间的二元联系集R来说，映射基数必然是以下情况之一：
* 一对一
* 一对多
* 多对一
* 多对多

### 码（主键）的选取

关系模式的码（主键）的概念直接适用于实体集。

联系集的码（主键）结构依赖于联系集的映射基数：
* 多对多的二元联系，参与实体集的主码属性的并集成为主码。
* 一对一的二元联系，任一实体集的主码属性可以选作主码。
* 多对一或一对多的二元联系，“多”的那一方实体集的主码属性成为主码
* 对于非二元联系，若没有基数限制，选超码作主码；如果有限制，就比较复杂了。

## E-R设计问题

### 使用实体集还是属性

具体问题具体分析，选择主要取决于概念的结构，以及相关的语义。

比如：
>学生有“家长”， “家长”应该是属性还是实体集？
如果只需存储学生家长的名字，那么“家长”应该是学生实体的一个属性
如果还需要存储家长的其它信息，比如工作和地址，那么“家长”就应该是一个实体集

两个常见错误：

* 用一个实体集的主码作为另一个实体集的属性，而不是用联系。这会将两个实体集间的关系隐含在属性中，是不好的设计。
* 相关实体集的主码属性作为联系集的属性。不能这么做的原因是联系集已经隐含了这些主码属性。（从E-R模式创建出的关系模型，这些主码属性可能会出现在联系集创建出的模式中。但它们不应该出现在联系集）

### 使用实体集还是联系集

指导原则：**当描述实体之间的行为（出现动词）时采用联系集**

例如：

>在 “老师教学生”这句话中
实体集：老师，学生
联系集：教

### 联系属性的归处

* 一对多或者多对一联系集：联系属性可以移到“多”方实体集
* 一对一联系集：联系属性可以移到任何“一”方实体集

总之，联系属性归到“多”的一方的实体集，若一样，归哪都行

## E-R图

总的来说，先将需求转化成E-R模型：实体集，联系集，它们的属性，参与和角色，映射基数，主码。然后根据它们设计E-R图

E-R图**作图规范**如下：

* 矩形：实体集
* 菱形：联系集
* 双菱形：连接到弱实体集的标志性联系集
* 椭圆：属性。下划线表示主码属性
* 双椭圆：多值属性
* 虚线椭圆：派生属性
* 线段：连接实体集和它的属性，连接联系集和它的描述性属性
* 描述联系集的映射基数：联系集用箭头指向“一”的一方，用线段连接“多”的一方
* 如果一个实体集和一个联系集间有两条或以上的连线，这些连线必须用角色标注
* 联系集与实体集用单直线连接表示部分参与，双直线连接表示完全参与（一般不考虑部分/全部参与）

****
以上作图规范是上课时老师讲的，和教材用书《数据库系统概念》第七版有一点区别：

* 分成两部分的矩形：实体集。第一部分是实体集的名字，第二部分包含实体集中的所有属性（也就是说实体集和它的属性是写在一个矩形中的，不用线段连接）
* 未分割的矩形：联系集的描述性属性
* 虚线：连接联系集和它的描述性属性

除以上三点，其余基本一致。
****

**例:有如下需求，设计E-R图**

>学生，包括学号，姓名和性别
教师，包括教师编号，姓名和年龄
教材，包括书号，书名和价格
课程，包括课程号和课程名
教师可能教几门课程，使用相同或不同的教材。一门课程可能有多个任课教师。
教师可以任多个学生的导师，但是学生只能有一个导师
学生分成组，小组内一个组长指导多个组员
学生可选修几门课程，每门课程都会有成绩。一门课程有许多学生选修

分析：

多对多：教师与课程，课程与教材，学生与课程
多对一：学生与老师，组员对组长
选修联系集需要有“成绩”这一描述性属性
“学生”实体集两次参与“指导”联系集，需要注明角色：组长，组员

从最终的E-R图中可以看出，实体集和属性集是名词概念，联系集是动词概念

![](pic/E-R%E5%9B%BE%E8%AE%BE%E8%AE%A1%E4%BE%8B%E5%AD%90.png)

## 拓展的E-R特性

包括：特化，概化，高层和低层实体集，属性基础和聚集

这部分上课没讲，看书了解即可

# 逻辑设计

这一阶段，将概念模式（E-R模型）转化为选定的某种数据模型（关系模型）
结果：得到数据库的逻辑模式

概念模型和数据模型：
* 概念模型用于描述：现实世界中事物和事物间的联系，即实体和实体间联系。 
* 数据模型用于描述：数据库中的数据和数据间联系。可以看作是把实体和实体间的联系数据化了

可以找到某种方法（例如元素之间的对应），将概念模型转化为数据模型。 
这一转化过程，也就是数据库设计的逻辑设计阶段


## E-R图转化为关系数据模型

**E-R模型 ( E-R图 )**
由实体集和实体集间的联系组成
基本元素：实体集、属性、联系集

**关系模型**
由若干关系模式组成
基本元素：关系（模式）、属性

E-R模型→概念模型：**从基本元素到基本元素**

具体地说：

* 实体集--->关系
* 属性--->属性
* 联系集--->关系/属性，具体来说：
  * 一对多和多对一（变成新属性）：“多”方关系添加属性：联系集自身属性+“一”方关系的主码（属性名可变）【**联系表与多方表连接**】
  * 一对一（变成新属性）：某个“一”方关系中添加属性：联系集自身属性+另一个“一”方关系的主码（属性可更名）【**联系表与任一一方表连接**】
  * 多对多：**单独成为新关系**
  * 三元或以上的联系集（变成新关系）：其属性包括所有参与实体集的主码，和联系集自身的属性（属性可更名）
* **多值属性**违反1NF，通过以下方法解决：
  从原关系中去掉多值属性，增加一个新关系。新关系包括多值属性和原关系的主码，新关系的主码就是这两者的组合

****
**例题：将如下E-R图转换为关系模型（表）**

![](pic/E-R%E5%9B%BE%E8%BD%AC%E5%8C%96%E6%88%90%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%BE%8B%E9%A2%98.png)

答案：

图书作者表是多值属性“作者”分离出的新关系
借阅关系是三元联系集，单独生成新关系（表）借阅表

![](pic/E-R%E5%9B%BE%E8%BD%AC%E5%8C%96%E6%88%90%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%AD%94%E6%A1%88.png)
****

## 关系模式规范化

通常情况下，数据库逻辑设计的结果（关系模式）并不唯一，为了进一步减少关系模式中的存在的异常、提高应用系统的性能，规范化理论是重要理论基础和有力工具。

一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级范式的关系模式集合，这种过程就叫关系模式的规范化

**设计选择：更大的设计（会出现数据冗余）**

例如：U ＝｛ Sno, Sdept, Mname, Cname, Grade ｝
将学生表和系信息表自然连接，构成的一张更大的表来代替两表

数据冗余：关系中有部分重复出现。带来的问题：
* 浪费存储空间（每一个系主任的名字重复出现）
* 更新异常：
  * 维护代价高：某系更换系主任后，系统必须修改与该系学生有关的每一个元组
  * 数据不一致：某系更换系主任后，如果不更新与之相关的每一个元组，则会产生不一致风险
* 插入异常：如果一个系刚成立，尚无学生，我们就无法把这个系及其系主任的信息存入数据库。
* 删除异常：如果某个系的学生全部毕业了， 那在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。

可以看出，虽然数据冗余对读操作可能有好处（已经连好表了，节省了联表查询的额外开销），但写操作会产生很多问题

这也引出了**逆规范化**的原则：查询带来的收益大于两次查询之间进行维护所需要的额外时间，那么可以选择逆规范化。


**设计选择：更小的模式（可能出现有损分解）**

不是所有的模式分解都是有益的。

**好的设计模式**

不会发生插入异常、删除异常、更新异常，数据冗余应尽可能少。


**范式**

* **1NF**：所有属性的域都是原子的，即每个属性都不可再分。不满足1NF，就不是关系型数据库。
* **2NF**：在1NF基础上，所有非主属性都完全函数依赖于主码
* **3NF**：在2NF基础上，所有非主属性都不传递依赖于候选码
  严格的判定：至少一项成立
  * 和BCNF条件一样
  * 对于R的函数依赖的闭包中的所有依赖x-->y，y-x的每个属性都包含在R的一个候选码中(BCNF不允许这种情况)
* **BCNF**：在3NF基础上，主属性对主码没有部分和传递函数依赖。
  严格的判定：对于R的函数依赖的闭包中的所有依赖（平凡的函数依赖当然符合），左侧（决定因素）都包含候选键【换句话说，左侧一定要是超键】，则符合BCNF范式
* **4NF**：在BCNF基础上，确保关系不存在多值依赖
* **5NF**
* **DKNF**
* **6NF**

![](https://img-blog.csdnimg.cn/20200512225949740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70)

在实际运用中，大多数情况下，设计到3NF或BCNF就可以了

**把握好度**

不能说规范化程度越高的关系模式就越好。（要看具体场景，有时逆规范化反而更好）

在设计数据库模式结构时，必须对现实世界的实际情况和用户应用需求作进一步分析，确定一个合适的、能够反映现实世界的模式。

规范化步骤可以在其中任何一步终止。

有时出于性能考虑，允许冗余数据的存在。

一般来说，具有函数依赖的数据库设计目标：
* BCNF
* 无损连接(数据等价)
* 保持依赖（语义等价）

有些情况很难达到所有的三个目标，通常舍弃目标3而选择目标1和2

## 函数依赖

### 定义和术语

**函数依赖的定义**
X→Y表示X相同，则有Y相同，X决定Y，是多对一的关系
同理，X双向箭头Y，互相决定，是一对一的关系
多对多不满足函数的定义，不讨论
>设R（U）是属性集U上的关系模式，X、Y是U的一个子集。r是R（U）中任意给定的一个关系。若对于r中任意两个元组s和t，当s[X] = t[X]时，就有s[Y] = t[Y]，则称属性子集X函数决定属性子集Y或者称Y函数依赖于X（Functional Dependence），记其为　X→Y。否则就称X不函数决定Y或者称Y不函数依赖于X。

**平凡与非平凡函数依赖**
平凡的函数依赖：自己决定自己or自己的子集
由于平凡的函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明，总是讨论非平凡函数依赖。

>在关系模式R(U)中，对于U的子集X和Y，
如果X→Y，但Y&#8840;X，则称X→Y是非平凡的函数依赖
若X→Y，但Y&#8838;X，则称X→Y是平凡的函数依赖
>
>例：在关系SC(Sno, Cno, Grade)中，
非平凡函数依赖：(Sno, Cno) → Grade
平凡函数依赖：(Sno, Cno) → Sno ，(Sno, Cno) → Cno

**完全与部分函数依赖**

在关系模式R(U)中，有X→Y：
* 如果X的单个子集不能决定Y（只有全部完整的X才能决定Y），则称Y完全函数依赖于X
* 如果X的单个子集可以决定Y，则称Y部分函数依赖于X

例：
>在关系SC(Sno, Cno, Grade)中有(Sno, Cno)→Grade
 由于：Sno 不能→Grade，Cno 不能→ Grade， 
 因此：Grade完全函数依赖于(Sno, Cno)

**传递函数依赖**

注意要和传递率区分，传递率是恒成立的：传递函数依赖是传递率的一种情况，关键是**Y不能→X**

>在关系模式R(U)中，如果X→Y，Y→Z，且Y&#8840;X，**Y&#8603;X**，则称Z传递函数依赖于X。
>
>例: 在关系Std(Sno, Sdept, Mname)中，有：
Sno → Sdept，Sdept → Mname
Mname传递函数依赖于Sno

### 函数依赖集的闭包

令F是一个函数依赖集，F的闭包是被F逻辑涵盖的所有函数依赖的集合，记作F^+^

求F^+^常用的7个公式

* 包含律: if Y &#8838; X，then X -> Y（平凡依赖）
* 传递律: if X -> Y and Y -> Z，then X -> Z
* 增广律: if X -> Y，then X Z -> Y Z
* 合并律: If X -> Y and X -> Z ，then X -> Y Z
* 分解律: If X -> Y Z ，then X -> Y and X -> Z
* 伪传递律: If X -> Y and W Y -> Z ，then X W -> Z
* set Accumulation Rule: If X -> Y Z and Z -> B ，then X -> Y Z B

### 属性集的闭包

令α为一个属性集，函数依赖集F下被α函数确定的所有属性的集合称为F下α的闭包，记作α^+^

**求属性集α闭包步骤（设α^+^为result集合）**

① 一开始，将α本身放入result集合

② 对于F中每个函数依赖X -> Y，如果X&#8838;result，就将Y放入result集合

注意：第二步是一直重复遍历的，直到result不能再扩充，这时result就是α的闭包α^+^

**属性集闭包α^+^的用途**

* 若α^+^为表中全部属性，则α是超键。更进一步地，若α无冗余属性，则α是候选键
* 通过检查Y是否&#8838;α^+^，判断出α -> Y是否成立(是否属于F^+^)
* 通过属性集闭包求出F^+^

### 正则（最小）覆盖

DBMS必须确保用户在关系上执行更新后，不破坏任何函数依赖。如果破坏了F中任一函数依赖，系统必须回滚。

可以通过测试与给定F具有相同闭包的简化集来**减少检测冲突的开销。**

F的正则覆盖F~c~是与F具有相同闭包的最小的简化集

**F~c~必须具有如下属性**：

* F~c~中任何函数依赖都不含无关属性（去除函数依赖中的无关属性，不改变F^+^）
* F~c~中函数依赖的左半部都是唯一的

**求正则覆盖步骤（正则覆盖未必唯一）**

*注：②③顺序可以调换*

① 使用分解律，将F中所有函数依赖的右侧分解为单一元素。确定每个属性集（出现在左侧）的闭包

②  去掉冗余的函数依赖（平凡的函数依赖直接去掉）

对于每个函数依赖，尝试去掉它，若每个属性集的闭包都保持不变，说明这个函数依赖是多余的，排除掉。

③ 去除左侧的无关属性

对于剩下的每个函数依赖X -> Y，判断每个x~i~&#8712;X：
如果Y&#8838;（X-x~i~）^+^，则x~i~是冗余属性，从X中去除

④ 如果③后函数依赖有变，还需再执行一次②

⑤ 利用合并律合并，得到正则覆盖

### 无损分解

**无损分解**：分解后的表自然连接后等于原来的表。保证了原始数据的完整性和准确性。

**有损分解**：一个关系分解后，产生信息丢失或不完整。通常是为了优化数据库的性能或者减少数据冗余而进行的，牺牲数据完整性和准确性来提升性能。

在实际数据库设计中，一般都需要对数据进行一定程度的有损分解，以使得数据库效率更高，但是应该保证至少达到适当的范式分解。设计者需要在数据完整性准确性与性能优化之间做出适当的平衡取舍。

**判断是否为无损分解（充分条件）**：关系R分解为R1和R2，如果R1&#8745;R2是R1或R2的超码，那么R上的分解就是无损分解（这里仅考虑二元分解，更多元的分解讨论比较复杂）

### 保持依赖

保持依赖指的是在分解关系（表）时要保持原有的依赖关系不变。

如果分解时忽略某些依赖关系，没有保持依赖，可能会导致数据冗余、重复或丢失，使得数据库中的数据变得不一致和不可靠。

**判定保持依赖**：

如果F上的每一个函数依赖都在其分解后的某一个关系上成立，则这个分解是保持依赖的（这是一个充分条件）

如果上述判断失败，并不能断言分解不是保持依赖的，还要使用下面的通用方法来做进一步判断：

>对F上的每一个α→β使用下面的过程：
result:=α;
while(result发生变化)do
    for each 分解后的Ri
        t=(result∩Ri)^+^ ∩Ri
        result=result∪t

这里的属性闭包是在函数依赖集F下计算出来的。如果result中包含β的所有属性，则函数依赖α→β保持。分解是保持依赖的当且仅当上述过程中F的所有依赖都被保持。

## 分解算法

### 3NF分解

3NF分解算法是保持依赖的，且是无损分解。值得注意的是，3NF分解算法得到的结果可能会满足BCNF范式。

步骤如下：

① 根据函数依赖集F算出正则覆盖F~c~，同时算出F~c~下的候选键

② 对于F~c~中每个函数依赖X -> Y，为它单独创建一张表（R~i~=XY）【前提是这个函数依赖不能含于另一个函数依赖中】

③ 在②创建的表（关系）中如果都不含候选键，那么为候选键单独创建一张表（关系）

```c
 令Fc为F的正则覆盖;
 i:= 0;
 for each Fc 中的函数依赖 α→β 
         i := i + 1
         Ri := αβ;
 if 模式 Rj, j = 1, 2, ..., i 都不包含R的候选码
 then
         i := i + 1
         Ri := R的任意候选码
 /*(以下代码可选)用来移除冗余关系，如果没有冗余关系则可以不care*/ 
 repeat
         if 模式 Rj包含于另一个模式Rk中
         then
                /*删除Rj*/
                Rj := Ri
                 i := i - 1
 until 不再有可以删除的Rj
 return (R1, R2, ..., Ri)
```

### BCNF分解

对满足1NF的模式R<U, F>作如下处理可分解成满足BCNF范式的模式R1, R2, ..., Rn：

*注意：一定是无损分解，但不一定保持函数依赖*

① 令reslut = {R}

② 计算F的函数闭包F^+^，给③提供判定（计算函数闭包还是挺麻烦的，所以在下面判断的时候挑一个函数依赖，判断一下是否被F逻辑蕴含即可）

③ 判断result中是否还存在不满足BCNF的模式

如果都满足，分解完成；如果存在某个模式不满足BCNF范式，则执行④

④ 选择一个在Ri上成立的非平凡函数依赖 α→β，并且 α→β 属于 F^+^，并且α∩β=∅。然后将模式Ri分解成两个模式，分别为 (Ri - β) 和 (α, β)。并且将Ri从result中移除，将新得到的两个模式添加到result中。接着回到③继续判断



```c
result := {R};
        done := false;
        计算F+;
        while(not done) do
              if(result中存在模式Ri不属于BCNF)
              then begin
                      令 α→β 为一个在Ri上成立的非平凡函数依赖，满足 α→β ∈ F+， 并且 α∩β  = ∅;
                      result := (result - Ri) ∪ (Ri - β) ∪ (α, β)
              end
              else done := true        
```

****
3NF分解算法的结果有时也属于BCNF，这提供了另一种生成BCNF的方法：

先用3NF算法分解，然后对结果中不满足BCNF范式的模式用BCNF分解算法分解，如果结果不保持函数依赖，则回退回3NF
****